<!DOCTYPE html>
<html lang="de">
	<head>
		<meta charset="utf-8">
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Einheit 5, Labor 1: Suchalgorithmen und Effizienz, Seite 5</title>
	</head>

	<body>
		<h2>Algorithmen kategorisieren</h2>
        <div class="todo">
            <h3>Lehrer*innenunterlagen und Lösungen müssen überprüft werden. --MF, 19.12.2018</h3>
        </div>
        <div class="learn"><strong>Auf dieser Seite</strong> vergleichst du vier Algorithmen und lernst, dass jeder davon in eine andere Laufzeitkategorie fällt.</div>

        <div class="forYouToDo" id="first">
			<ol>
				<li>
                    Suche den Block <img src="/bjc-r/img/5-algorithms/25000integers.png" alt="Block „25,000 integers starting from ()“" title="Block „25,000 integers starting from ()“" /> in deinem Projekt und miss seine Laufzeit für verschiedene Startzahlen.<br />
                    <table class="bordered center standard" summary="Tabelle mit Ausgangszahlen und der benötigten Zeit des Blocks 25,000 integers starting from">
                        <tr>
                            <th scope="col">Startzahl</th>
                            <th scope="col">Zeit für <code>25,000 integers</code></th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100,000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>1,000,000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10,000,000</td>
                            <td></td>
                        </tr>
                    </table>
                </li>
                <li><img class="imageRight" src="/bjc-r/img/icons/talk-with-your-partner.png" alt="Sprich mit deiner Partnerin/deinem Partner" title="Sprich mit deiner Partnerin/deinem Partner" /> Sieh dir die Tabelle an. Wie würdest du beschreiben, was mit der Zeit passiert, wenn die Startzahl größer wird? Formuliere eine Hypothese über das Muster.</li>
                <li>
                    <div class="sidenoteBig">Es gibt mehrere Möglichkeiten, eine Liste zu sortieren; einige lernst du in Einheit&nbsp;8 kennen. Dieser Block <code>sort</code> verwendet einen „Insertion-Sort“-Algorithmus.</div>
                    Suche den Block <img class="inline nopadtb" src="/bjc-r/img/5-algorithms/sort.png" alt="Block „sort (Liste)“" title="Block „sort (Liste)“" /> in deinem Projekt und miss seine Laufzeit für jede Listenlänge.<br />
                    <table class="bordered center standard" summary="Tabelle mit Listenlängen und der benötigten Zeit des Blocks sort">
                        <tr>
                            <th scope="col">Listenlänge</th>
                            <th scope="col">Zeit für <code>sort</code></th>
                        </tr>
                        <tr>
                            <td>10</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                        </tr>
                    </table>
                </li>
                <li><img class="inline" src="/bjc-r/img/icons/talk-with-your-partner-mini.png" alt="Besprich es mit deiner Partnerin/deinem Partner" title="Besprich es mit deiner Partnerin/deinem Partner" />Wie würdest du beschreiben, was mit der Zeit passiert, wenn die Eingabeliste größer wird? Formuliere eine Hypothese.</li>
			</ol>
		</div>

        <p>Du kannst Algorithmen nach der Laufzeit klassifizieren. <!--To classify an algorithm, you look at the number of steps it takes to complete the algorithm and compare it to the size of the input. For example, <code>25,000 integers</code> takes <em>constant time:</em> computing 25,000 integers starting at seven takes as long as computing 25,000 integers starting at seven million. As a second example, <code>linear search</code> takes <em>linear time:</em> if you have ten times as many words in the dictionary, then it takes ten times as long to search through them all. As a third example, consider the <code>sort</code> algorithm you timed. It takes <em>quadratic time:</em> multiplying the input size by ten multiplies the time required by 10<sup>2</sup>. As another example, consider the <code>binary search</code> algorithm you timed. In binary search, multiplying the input size by ten <em>adds</em> a constant amount to the time required instead of multiplying by a constant amount. This is an example of <em>sublinear time</em>.--></p>

        <div class="forYouToDo">
        <div class="vocabBig">: <strong>Lineare Zeit</strong>, <strong>sublineare Zeit</strong>, <strong>konstante Zeit</strong> und <strong>quadratische Zeit</strong>
            <ul>
                <li>Ein Algorithmus benötigt <strong>lineare Zeit</strong>, wenn die Zahl der Schritte proportional zur Eingabegröße ist; verdoppelst du die Eingabe, verdoppelt sich die Laufzeit.</li>
                <li>Ein Algorithmus benötigt <strong>sublineare Zeit</strong>, wenn die Schrittzahl langsamer wächst als die Eingabegröße.</li>
                <li>Ein Algorithmus benötigt <strong>konstante Zeit</strong>, wenn die Schrittzahl unabhängig von der Eingabegröße gleich bleibt.</li>
                <li>Ein Algorithmus benötigt <strong>quadratische Zeit</strong>, wenn die Schrittzahl proportional zum <em>Quadrat</em> der Eingabegröße ist.</li>
            </ul>
        </div>
			<ol start="5">
				<li>Sieh dir deine Tabelle für <code>linear search</code> noch einmal an. Bestätige, dass sich die Laufzeit ungefähr verzehnfacht, wenn die Listenlänge verzehnfacht wird (<em>lineare Zeit</em>).<!--the search time for the <var>100,000 word list</var> is (about) ten times as long as the time for the <var>10,000 word list</var>, which is (about) ten times as long as the time for the <var>1,000 word list</var>.--></li>
				<li>Sieh dir deine Tabelle für <code>binary search</code> noch einmal an. Bestätige, dass die Suchzeit für jede Wortliste kleiner ist als bei der linearen Suche (<em>sublineare Zeit</em>).</li>
                <li>Sieh dir deine Tabelle für <code>25,000 integers</code> noch einmal an. Bestätige, dass die Laufzeit unabhängig von der Eingabe ungefähr gleich bleibt (<em>konstante Zeit</em>).</li>
				<li>Sieh dir deine Tabelle für <code>sort</code> noch einmal an. Bestätige, dass sich die Laufzeit ungefähr verhundertfacht, wenn die Listenlänge verzehnfacht wird (<em>quadratische Zeit</em>).<!--Confirm that the time to sort the <var>100,000 word list</var> is (about) one hundred times as long as the time for the <var>10,000 word list</var>, which is (about) one hundred times as long as the time for the <var>1,000 word list</var>.--></li>
			</ol>
		</div>

        <p>Der Unterschied zwischen linearer Suche und binärer Suche kann sehr wichtig sein, wenn du eine Liste mit zehn Millionen Einträgen durchsuchen musst. Der <em>wichtigste</em> Unterschied bei der Algorithmuseffizienz ist jedoch der zwischen polynomieller Zeit (proportional zu einer beliebigen Potenz der Eingabegröße) und exponentieller Zeit.</p>

        <div class="vocabFullWidth">: <strong>Polynomielle Zeit</strong> und <strong>exponentielle Zeit</strong>
            <ul>
                <li>
                    Ein Algorithmus benötigt <strong>polynomielle Zeit</strong>, wenn die Zahl der Schritte durch eine Potenz der Eingabegröße nach oben begrenzt ist, zum Beispiel konstant (<em>n</em><sup>0</sup>), sublinear, linear (<em>n</em><sup>1</sup>), quadratisch (<em>n</em><sup>2</sup>) oder kubisch (<em>n</em><sup>3</sup>).

                </li>
                <li>
                    Ein Algorithmus benötigt <strong>exponentielle Zeit</strong>, wenn die Zahl der Schritte proportional zu einer Exponentialfunktion der Eingabegröße ist, etwa 2<sup><em>n</em></sup>, 10<sup><em>n</em></sup> usw. Das ist deutlich langsamer als jede polynomielle Laufzeit.
                </li>
            </ul>
        </div>
        <p>Bei einem exponentiellen Algorithmus verdoppelt schon das <em>Addieren von 1</em> zur Eingabegröße (<em>n</em>) eines 2<sup><em>n</em></sup>-Algorithmus die Schrittzahl! Wenn die Eingabegröße zum Beispiel 20 ist, sind <em>alle</em> polynomialen Algorithmen schnell genug, aber ein exponentieller Algorithmus könnte viele <em>Jahre</em> benötigen.</p>

        <div class="commentBig">Animation verlangsamen, Beschriftungen ergänzen, exponentielle Kurve rot einfärben und die seltsamen Aussetzer im Diagramm beheben; außerdem fehlt dem Bild ein Alt-Text ähnlich dem aus dem auskommentierten Text. --MF, 2.4.2019</div>
        <img class="indent noshadow" src="/bjc-r/img/5-algorithms/algorithm-time-graphs.gif" alt="" title="" /><br />

        <div class="examFullWidth">
            <ul>
                <div class="ap-standard">AAP-4.A.7</div>
                <li>Der Begriff „<strong>angemessene Laufzeit</strong>“ beschreibt jeden Algorithmus, der in polynomialer Zeit läuft. Algorithmen mit exponentieller Laufzeit gelten <em>nicht</em> als angemessen.</li>
            </ul>
        </div>

        <div class="todo"><div class="endnote">Im Internet verwenden viele Menschen das Wort „exponentiell“, wenn sie einfach „sehr schnell“ meinen. Beispielsweise in reißerischen Überschriften. Jetzt weißt du es besser.</div></div>

        <!--<img class="indent noshadow" style="height:300px" src="/bjc-r/img/5-algorithms/size-vs-time.png" alt="graph of size vs. time showing a straight line through the origin and up to the right with the points for x=10,000 and x=100,000 marked" title="graph of size vs. time showing a straight line through the origin and up to the right with the points for x=10,000 and x=100,000 marked" />-->

        <div class="ap-standard">AAP-2.M.2 text before bullets</div>
        <p>Einer der Gründe, warum es sich lohnt, diese Kategorien zu kennen, ist, dass du das Rad nicht neu erfinden musst. Wenn eine Liste sortiert ist, kannst du sie mit <code>binary search</code> in sublinearer Zeit durchsuchen. Schreibst du also ein Programm, das wiederholt eine Liste durchsucht, lohnt es sich, die Liste vorher zu sortieren. Wenn du existierende Algorithmen kennst, kannst du darauf aufbauen und eigene entwickeln.</p>

        <p>Alle Algorithmen, die du in diesem Labor bisher untersucht hast (<code>linear search</code>, <code>binary search</code>, <code>25,000 integers</code> und <code>sort</code>), laufen in angemessener Zeit. Die folgende optionale Aktivität zeigt ein Beispiel für einen Algorithmus mit exponentieller Laufzeit.</p>
        <div class="ifTime">
			<ol start="9">
				<p>Ein Problem, das dir vielleicht bekannt vorkommt, ist das Berechnen eines beliebigen Elements im Pascalschen Dreieck. In diesem Dreieck entsteht jede Zahl, indem du die beiden Zahlen darüber addierst. Zum Beispiel gilt 4 + 6 = 10 und 15 + 6 = 21, wie unten zu sehen ist. Die erste und die letzte Zahl jeder Zeile, die keine zwei Zahlen über sich haben, sind 1.<br />
                    <img class="indent noshadow" src="/bjc-r/img/5-algorithms/pascals-triangle-numbers.jpg" alt="
          1
         1 1
        1 2 1
       1 3 3 1
      1 4 6 4 1
    1 5 10 10 5 1
   1 6 15 20 15 6 1
 1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1" title="
          1
         1 1
        1 2 1
       1 3 3 1
      1 4 6 4 1
    1 5 10 10 5 1
   1 6 15 20 15 6 1
 1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1" />
                    <img class="indent" src="/bjc-r/img/5-algorithms/pascals-triangle-6-3-reporting.png" alt="Pascalsches Dreieck: row: (6) position (3) meldet 10" title="Pascalsches Dreieck: row: (6) position (3) meldet 10" />
                </p>
                <li>
                    Suche den Block <img class="inline" src="/bjc-r/img/8-recursive-reporters/pascals-triangle.png" alt="Block „pascals triangle, row: () position: ()“" title="Block „pascals triangle, row: () position: ()“" /> in deinem Projekt und miss seine Laufzeit für verschiedene Eingaben.<br />
                    <div class="endnote">Falls die Berechnungen zu lange dauern, kannst du dein Programm stoppen. Fülle die Tabelle einfach so weit aus, wie es die Geschwindigkeit deines Computers erlaubt.</div>
                    <table class="bordered center" summary="Tabelle mit Eingaben und Laufzeiten für den Block pascals triangle">
                        <tr>
                            <th scope="col" style="white-space: nowrap;">Eingaben</th>
                            <th scope="col" style="white-space: nowrap;">Zeit für <code>pascals triangle</code></th>
                        </tr>
                        <tr>
                            <td>5, 2</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10, 5</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>15, 7</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>20, 10</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>25, 12</td>
                            <td></td>
                        </tr>
                    </table>
                    <div class="endnote">Der Wert für <var>row</var> ist die relevante Eingabe für <code>pascals triangle</code>. (Die Eingabe <var>position</var> sorgt dafür, dass du eine Position nahe der Mitte der Zeile misst, die länger zum Berechnen braucht.)</div>
                    <p>Diese <var>row</var>-Werte sind winzig im Vergleich zu den Eingabegrößen der Algorithmen <code>linear search</code>, <code>binary search</code> und <code>sort</code>, und trotzdem dauert <code>pascals triangle</code> deutlich länger. Dein Computer schafft wahrscheinlich kaum mehr als <var>25</var>.</p>
                    <div class="endnote">Dieser Algorithmus addiert rekursiv die beiden Zahlen darüber, indem er sich selbst aufruft. Es gibt jedoch effizientere Algorithmen, die einen Wert im Pascalschen Dreieck in linearer Zeit berechnen.</div>
                </li>
			</ol>
		</div>

        <div class="forYouToDo">
			<ol start="10">
                <div class="ap-standard">AAP-4.A Teil a</div>
                <li>Schreibe einen Absatz, der den Unterschied zwischen Algorithmen mit angemessener Laufzeit und solchen ohne angemessene Laufzeit erklärt.</li>
				<li>
                    Diese Frage ähnelt Aufgaben auf der AP-CSP-Prüfung.
                    <!-- Question 1 -->
                    <div class="assessment-data" type="multiplechoice" identifier="Timing of database tasks"
                        hasinlinefeedback="true" maxchoices="1" responseIdentifier="ri1" shuffle="true">
                        <div class="prompt">
                            Die folgende Tabelle zeigt, wie lange verschiedene Aufgaben für die Daten von Städten unterschiedlicher Größe dauern.
                            <p>
                                <table class="bordered center standard" summary="Stunden für Datenaufgaben in Städten verschiedener Größe">
                                    <tr>
                                        <th scope="col">Aufgabe</th>
                                        <th scope="col">Kleine Stadt<br />(Einwohnerzahl 1,000)</th>
                                        <th scope="col">Mittelgroße Stadt<br />(Einwohnerzahl 10,000)</th>
                                        <th scope="col">Große Stadt<br />(Einwohnerzahl 100,000)</th>
                                    </tr>
                                    <tr>
                                        <th scope="row">Daten eingeben</th>
                                        <td>2 Stunden</td>
                                        <td>20 Stunden</td>
                                        <td>200 Stunden</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Daten sichern</th>
                                        <td>0,5 Stunden</td>
                                        <td>5 Stunden</td>
                                        <td>50 Stunden</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Daten durchsuchen</th>
                                        <td>5 Stunden</td>
                                        <td>15 Stunden</td>
                                        <td>25 Stunden</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Daten sortieren</th>
                                        <td>0,01 Stunden</td>
                                        <td>1 Stunde</td>
                                        <td>100 Stunden</td>
                                    </tr>
                                </table>
                            </p>
                            Basierend auf den Angaben in der Tabelle: Welche Aufgabe wird voraussichtlich die <em><strong>meiste</strong></em> Zeit in Anspruch nehmen, wenn du sie auf eine Stadt mit 1,000,000 Einwohner*innen überträgst?
                        </div>
                        <div class="choice" identifier="c1">
                            <div class="text">Daten eingeben</div>
                            <div class="feedback">
                                <!--Entering data seems to take <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-entering-data.jpg" alt="population/1000" title="population/1000" /> hours, so for a population of 1,000,000, it should take about 2,000 hours.-->
                                Wenn sich die Einwohnerzahl verzehnfacht, verzehnfacht sich auch die Zeit fürs Eingeben. Für 1,000,000 Einwohner*innen wären das also etwa 10&times;200 = 2000 Stunden.
                            </div>
                        </div>
                        <div class="choice" identifier="c2">
                            <div class="text">Daten sichern</div>
                            <div class="feedback">
                                <!--Backing up data seems to take about <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-backing-up.jpg" alt="5^((population/1000)-1)" title="5^((population/1000)-1)" /> hours, so for a population of 1,000,000, it should take about 125 hours.-->
                                Wenn sich die Einwohnerzahl verzehnfacht, verzehnfacht sich auch die Zeit fürs Sichern. Für 1,000,000 Einwohner*innen wären das also etwa 10&times;50 = 500 Stunden.
                            </div>
                        </div>
                        <div class="choice" identifier="c3">
                            <div class="text">Daten durchsuchen</div>
                            <div class="feedback">
                                Die Suchzeit wächst offenbar um ungefähr 10 Stunden, wenn sich die Einwohnerzahl verzehnfacht. Für 1,000,000 Einwohner*innen wären das also rund 35 Stunden.
                            </div>
                        </div>
                        <div class="choice" identifier="c4">
                            <div class="text">Daten sortieren</div>
                            <div class="feedback">
                                Richtig! <!--Sorting the data seems to go up exponentially as the the population grows. For a population of 1,000,000, it should take about 10,000 hours.--> Wenn sich die Einwohnerzahl verzehnfacht, verhundertfacht sich die Zeit fürs Sortieren. Für 1,000,000 Einwohner*innen wären das etwa 100&times;100 = 10,000 Stunden.
                            </div>
                        </div>
                        <div class="responseDeclaration" identifier="ri1">
                            <div class="correctResponse" identifier="c4"></div>
                        </div>
                    </div>
                </li>
            </ol>
        </div>


    </body>
</html>
